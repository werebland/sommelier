/**
 * Sticky Events
 */
// Constants
var StickyEvent = {
  CHANGE: 'sticky-change',
  STUCK: 'sticky-stuck',
  UNSTUCK: 'sticky-unstuck'
};
var ClassName = {
  SENTINEL: 'sticky-events--sentinel',
  SENTINEL_TOP: 'sticky-events--sentinel-top',
  SENTINEL_BOTTOM: 'sticky-events--sentinel-bottom'
};
var STICKY_SELECTOR = '.sticky-events'; // Collection of all observers, used when needing to `unobserve` stickies

var observers = [];
/**
 * Reset the DOM to it's pre-sticky state.
 * This function stops observing sticky sentinels before removing them from the DOM.
 *
 * @param {Boolean} resetStickies   Optionally fire one last `sticky-unstick` event to reset the sticky to it's pre-sticky state
 */

function unobserveStickyEvents() {
  var resetStickies = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  observers.forEach(function (_ref) {
    var container = _ref.container,
        observer = _ref.observer,
        sentinels = _ref.sentinels;

    if (resetStickies) {
      Array.from(container.querySelectorAll(STICKY_SELECTOR)).forEach(function (sticky) {
        return fire(false, sticky);
      });
    }

    sentinels.forEach(function (sentinel) {
      return sentinel.remove();
    });
    observer.disconnect();
    observer = null;
  });
  observers.length = 0;
}
/**
 * Initialize the intersection observers on `.sticky` elements within the specified container.
 * Container defaults to `document`.
 *
 * @export
 * @param {Element|HTMLDocument|Document} container
 */

function observeStickyEvents() {
  var container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;

  if (window.self !== window.top) {
    console.warn('StickyEvents: There are issues with using IntersectionObservers in an iframe, canceling initialization. Please see https://github.com/w3c/IntersectionObserver/issues/183');
    return;
  }

  window.requestAnimationFrame(function () {
    observers.push(observeHeaders(container));
    observers.push(observeFooters(container));
  });
}
/**
 * Sets up an intersection observer to notify `document` when elements with the `ClassName.SENTINEL_TOP` become
 * visible/hidden at the top of the sticky container.
 *
 * @param {Element|HTMLDocument} container
 * @returns {{container: *, observer: IntersectionObserver, sentinels: Array<Element>}}
 */

function observeHeaders(container) {
  var observer = new IntersectionObserver(function (records) {
    records.forEach(function (record) {
      var boundingClientRect = record.boundingClientRect,
          rootBounds = record.rootBounds;
      var stickyParent = record.target.parentElement;
      var stickyTarget = stickyParent.querySelector(STICKY_SELECTOR);
      stickyParent.style.position = 'relative';

      if (boundingClientRect.bottom >= rootBounds.top && boundingClientRect.bottom < rootBounds.bottom) {
        fire(false, stickyTarget);
      } else if (boundingClientRect.bottom < rootBounds.top) {
        fire(true, stickyTarget);
      }
    });
  }, Object.assign({
    threshold: [0]
  }, !(container instanceof HTMLDocument) && {
    root: container
  }));
  var sentinels = addSentinels(container, ClassName.SENTINEL_TOP);
  sentinels.forEach(function (sentinel) {
    return observer.observe(sentinel);
  });
  return {
    container: container,
    observer: observer,
    sentinels: sentinels
  };
}
/**
 * Sets up an intersection observer to notify `document` when elements with the `ClassName.SENTINEL_BOTTOM` become
 * visible/hidden at the bottom of the sticky container.
 *
 * @param {Element|HTMLDocument} container
 * @returns {{container: *, observer: IntersectionObserver, sentinels: Array<Element>}}
 */


function observeFooters(container) {
  var observer = new IntersectionObserver(function (records) {
    records.forEach(function (record) {
      var boundingClientRect = record.boundingClientRect,
          rootBounds = record.rootBounds;
      var stickyTarget = record.target.parentElement.querySelector(STICKY_SELECTOR);

      if (boundingClientRect.top < rootBounds.top && boundingClientRect.bottom < rootBounds.bottom) {
        fire(false, stickyTarget);
      } else if (boundingClientRect.bottom > rootBounds.top && isSticking(stickyTarget)) {
        fire(true, stickyTarget);
      }
    });
  }, Object.assign({
    threshold: [1]
  }, !(container instanceof HTMLDocument) && {
    root: container
  })); // Add the bottom sentinels to each section and attach an observer.

  var sentinels = addSentinels(container, ClassName.SENTINEL_BOTTOM);
  sentinels.forEach(function (sentinel) {
    return observer.observe(sentinel);
  });
  return {
    container: container,
    observer: observer,
    sentinels: sentinels
  };
}
/**
 * Dispatch the following events:
 * - `sticky-change`
 * - `sticky-stuck` or `sticky-unstuck`
 *
 * @param {Boolean} isSticky
 * @param {Element} stickyTarget
 */


function fire(isSticky, stickyTarget) {
  stickyTarget.dispatchEvent(new CustomEvent(StickyEvent.CHANGE, {
    detail: {
      isSticky: isSticky
    }
  }));
  stickyTarget.dispatchEvent(new CustomEvent(isSticky ? StickyEvent.STUCK : StickyEvent.UNSTUCK));
}
/**
 * Add sticky sentinels
 *
 * @param {Element|HTMLDocument} container
 * @param {String} className
 * @returns {Array<Element>}
 */


function addSentinels(container, className) {
  return Array.from(container.querySelectorAll(STICKY_SELECTOR)).map(function (stickyElement) {
    var sentinel = document.createElement('div');
    var stickyParent = stickyElement.parentElement;
    sentinel.classList.add(ClassName.SENTINEL, className);

    switch (className) {
      case ClassName.SENTINEL_TOP:
        {
          stickyParent.insertBefore(sentinel, stickyElement);
          Object.assign(sentinel.style, getSentinelPosition(stickyElement, sentinel, className));
          break;
        }

      case ClassName.SENTINEL_BOTTOM:
        {
          stickyParent.appendChild(sentinel);
          Object.assign(sentinel.style, getSentinelPosition(stickyElement, sentinel, className));
          break;
        }
    }

    return sentinel;
  });
}
/**
 * Determine the position of the sentinel
 *
 * @param {Element|Node} stickyElement
 * @param {Element|Node} sentinel
 * @param {String} className
 * @returns {Object}
 */


function getSentinelPosition(stickyElement, sentinel, className) {
  var stickyStyle = window.getComputedStyle(stickyElement);
  var parentStyle = window.getComputedStyle(stickyElement.parentElement);

  switch (className) {
    case ClassName.SENTINEL_TOP:
      return {
        top: "calc(".concat(stickyStyle.getPropertyValue('top'), " * -1)"),
        height: 0
      };

    case ClassName.SENTINEL_BOTTOM:
      var parentPadding = parseInt(parentStyle.paddingTop);
      return {
        bottom: stickyStyle.top,
        height: "".concat(stickyElement.getBoundingClientRect().height + parentPadding, "px")
      };
  }
}
/**
 * Determine if the sticky element is currently sticking in the browser
 *
 * @param {Element} stickyElement
 * @returns {boolean}
 */


function isSticking(stickyElement) {
  var topSentinel = stickyElement.previousElementSibling;
  var stickyOffset = stickyElement.getBoundingClientRect().top;
  var topSentinelOffset = topSentinel.getBoundingClientRect().top;
  var difference = Math.round(Math.abs(stickyOffset - topSentinelOffset));
  var topSentinelTopPosition = Math.abs(parseInt(window.getComputedStyle(topSentinel).getPropertyValue('top')));
  return difference !== topSentinelTopPosition;
}

export { StickyEvent, unobserveStickyEvents, observeStickyEvents };
