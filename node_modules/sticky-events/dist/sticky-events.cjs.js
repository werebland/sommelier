'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

/**
 * Todo:
 * - Allow adding new stickies to a set of stickies
 * - Improve README (at least describe options)
 */

/**
 * @deprecated
 * @type {{CHANGE: string, STUCK: string, UNSTUCK: string}}
 */
var StickyEvent = {
  CHANGE: 'sticky-change',
  STUCK: 'sticky-stuck',
  UNSTUCK: 'sticky-unstuck'
};
var ClassName = {
  SENTINEL: 'sticky-events--sentinel',
  SENTINEL_TOP: 'sticky-events--sentinel-top',
  SENTINEL_BOTTOM: 'sticky-events--sentinel-bottom'
};
var STICKY_SELECTOR = '.sticky-events'; // StickyEvents class

var StickyEvents =
/*#__PURE__*/
function () {
  /**
   * Initialize a set of sticky elements with events
   *
   * @param {Element|Document} container
   * @param {boolean} enabled
   * @param {string} stickySelector
   */
  function StickyEvents() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$container = _ref.container,
        container = _ref$container === void 0 ? document : _ref$container,
        _ref$enabled = _ref.enabled,
        enabled = _ref$enabled === void 0 ? true : _ref$enabled,
        _ref$stickySelector = _ref.stickySelector,
        stickySelector = _ref$stickySelector === void 0 ? STICKY_SELECTOR : _ref$stickySelector;

    _classCallCheck(this, StickyEvents);

    this.container = container;
    this.observers = [];
    this.stickyElements = document.querySelectorAll(stickySelector);
    this.stickySelector = stickySelector;

    if (enabled) {
      this.enableEvents();
    }
  }

  _createClass(StickyEvents, [{
    key: "enableEvents",
    value: function enableEvents() {
      observeStickyEvents(this.container, this.observers, this.stickySelector);
    }
  }, {
    key: "disableEvents",
    value: function disableEvents() {
      var resetStickies = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      unobserveStickyEvents(resetStickies, this.observers, this.stickySelector);
    }
  }]);

  return StickyEvents;
}(); // Events
StickyEvents.CHANGE = StickyEvent.CHANGE;
StickyEvents.STUCK = StickyEvent.STUCK;
StickyEvents.UNSTUCK = StickyEvent.UNSTUCK; // Collection of all observers, used when needing to `unobserve` stickies

var globalObservers = [];
/**
 * Reset the DOM to it's pre-sticky state.
 * This function stops observing sticky sentinels before removing them from the DOM.
 *
 * @deprecated
 * @param {boolean} resetStickies     Optionally fire one last `sticky-unstick` event to reset the sticky to it's pre-sticky state
 * @param {array<object>} observers   A collection of the elements being observed, along with their containers and sentinels (see what `observeHeaders` and `observeFooters` returns)
 * @param {string} stickySelector     The CSS selector applied to the sticky DOM elements
 */

function unobserveStickyEvents() {
  var resetStickies = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  var observers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : globalObservers;
  var stickySelector = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : STICKY_SELECTOR;
  observers.forEach(function (_ref2) {
    var container = _ref2.container,
        observer = _ref2.observer,
        sentinels = _ref2.sentinels;

    if (resetStickies) {
      Array.from(container.querySelectorAll(stickySelector)).forEach(function (sticky) {
        return fire(false, sticky);
      });
    }

    sentinels.forEach(function (sentinel) {
      return sentinel.remove();
    });
    observer.disconnect();
    observer = null;
  });
  observers.length = 0;
}
/**
 * Initialize the intersection observers on `.sticky` elements within the specified container.
 * Container defaults to `document`.
 *
 * @deprecated
 * @param {Element|Document} container
 * @param {string} stickySelector       The CSS selector applied to the sticky DOM elements
 * @param {array<object>} observers     A collection of the elements being observed, along with their containers and sentinels (see what `observeHeaders` and `observeFooters` returns)
 */

function observeStickyEvents() {
  var container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
  var observers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : globalObservers;
  var stickySelector = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : STICKY_SELECTOR;

  if (window.self !== window.top) {
    console.warn('StickyEvents: There are issues with using IntersectionObservers in an iframe, canceling initialization. Please see https://github.com/w3c/IntersectionObserver/issues/183');
    return;
  }

  observers.push(observeHeaders(container, stickySelector));
  observers.push(observeFooters(container, stickySelector));
}
/**
 * Sets up an intersection observer to notify `document` when elements with the `ClassName.SENTINEL_TOP` become
 * visible/hidden at the top of the sticky container.
 *
 * @param {Element|HTMLDocument} container
 * @param {string} stickySelector     The CSS selector applied to the sticky DOM elements
 * @returns {{container: *, observer: IntersectionObserver, sentinels: Array<Element>}}
 */

function observeHeaders(container) {
  var stickySelector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : STICKY_SELECTOR;
  var observer = new IntersectionObserver(function (records) {
    records.forEach(function (record) {
      var boundingClientRect = record.boundingClientRect,
          rootBounds = record.rootBounds;
      var stickyParent = record.target.parentElement;
      var stickyTarget = stickyParent.querySelector(stickySelector);
      stickyParent.style.position = 'relative';

      if (boundingClientRect.bottom > rootBounds.top && boundingClientRect.bottom < rootBounds.bottom) {
        fire(false, stickyTarget);
      } else if (boundingClientRect.bottom <= rootBounds.top) {
        fire(true, stickyTarget);
      }
    });
  }, Object.assign({
    threshold: [0]
  }, !(container instanceof HTMLDocument) && {
    root: container
  }));
  var sentinels = addSentinels(container, ClassName.SENTINEL_TOP, stickySelector);
  sentinels.forEach(function (sentinel) {
    return observer.observe(sentinel);
  });
  return {
    container: container,
    observer: observer,
    sentinels: sentinels
  };
}
/**
 * Sets up an intersection observer to notify `document` when elements with the `ClassName.SENTINEL_BOTTOM` become
 * visible/hidden at the bottom of the sticky container.
 *
 * @param {Element|HTMLDocument} container  The DOM element that contains your sticky elements
 * @param {string} stickySelector           The CSS selector applied to the sticky DOM elements
 * @returns {{container: *, observer: IntersectionObserver, sentinels: Array<Element>}}
 */


function observeFooters(container) {
  var stickySelector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : STICKY_SELECTOR;
  var observer = new IntersectionObserver(function (records) {
    records.forEach(function (record) {
      var boundingClientRect = record.boundingClientRect,
          rootBounds = record.rootBounds;
      var stickyTarget = record.target.parentElement.querySelector(stickySelector);

      if (boundingClientRect.top < rootBounds.top && boundingClientRect.bottom < rootBounds.bottom) {
        fire(false, stickyTarget);
      } else if (boundingClientRect.bottom > rootBounds.top && isSticking(stickyTarget)) {
        fire(true, stickyTarget);
      }
    });
  }, Object.assign({
    threshold: [1]
  }, !(container instanceof HTMLDocument) && {
    root: container
  })); // Add the bottom sentinels to each section and attach an observer.

  var sentinels = addSentinels(container, ClassName.SENTINEL_BOTTOM, stickySelector);
  sentinels.forEach(function (sentinel) {
    return observer.observe(sentinel);
  });
  return {
    container: container,
    observer: observer,
    sentinels: sentinels
  };
}
/**
 * Dispatch the following events:
 * - `sticky-change`
 * - `sticky-stuck` or `sticky-unstuck`
 *
 * @param {Boolean} isSticky
 * @param {Element} stickyTarget
 */


function fire(isSticky, stickyTarget) {
  stickyTarget.dispatchEvent(new CustomEvent(StickyEvent.CHANGE, {
    detail: {
      isSticky: isSticky
    }
  }));
  stickyTarget.dispatchEvent(new CustomEvent(isSticky ? StickyEvent.STUCK : StickyEvent.UNSTUCK));
}
/**
 * Add sticky sentinels
 *
 * @param {Element|HTMLDocument} container
 * @param {String} className
 * @param {string} stickySelector     The CSS selector applied to the sticky DOM elements
 * @returns {Array<Element>}
 */


function addSentinels(container, className) {
  var stickySelector = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : STICKY_SELECTOR;
  return Array.from(container.querySelectorAll(stickySelector)).map(function (stickyElement) {
    var sentinel = document.createElement('div');
    var stickyParent = stickyElement.parentElement; // Apply styles to the sticky element

    stickyElement.style.cssText = "\n      position: -webkit-sticky;\n      position: sticky;\n    "; // Apply default sentinel styles

    sentinel.classList.add(ClassName.SENTINEL, className);
    Object.assign(sentinel.style, {
      left: 0,
      position: 'absolute',
      right: 0,
      visibility: 'hidden'
    });

    switch (className) {
      case ClassName.SENTINEL_TOP:
        {
          stickyParent.insertBefore(sentinel, stickyElement); // Apply styles specific to the top sentinel

          Object.assign(sentinel.style, getSentinelPosition(stickyElement, sentinel, className), {
            position: 'relative'
          });
          break;
        }

      case ClassName.SENTINEL_BOTTOM:
        {
          stickyParent.appendChild(sentinel); // Apply styles specific to the bottom sentinel

          Object.assign(sentinel.style, getSentinelPosition(stickyElement, sentinel, className));
          break;
        }
    }

    return sentinel;
  });
}
/**
 * Determine the position of the sentinel
 *
 * @param {Element|Node} stickyElement
 * @param {Element|Node} sentinel
 * @param {String} className
 * @returns {Object}
 */


function getSentinelPosition(stickyElement, sentinel, className) {
  var stickyStyle = window.getComputedStyle(stickyElement);
  var parentStyle = window.getComputedStyle(stickyElement.parentElement);

  switch (className) {
    case ClassName.SENTINEL_TOP:
      return {
        top: "calc(".concat(stickyStyle.getPropertyValue('top'), " * -1)"),
        height: 0
      };

    case ClassName.SENTINEL_BOTTOM:
      var parentPadding = parseInt(parentStyle.paddingTop);
      return {
        bottom: stickyStyle.top,
        height: "".concat(stickyElement.getBoundingClientRect().height + parentPadding, "px")
      };
  }
}
/**
 * Determine if the sticky element is currently sticking in the browser
 *
 * @param {Element} stickyElement
 * @returns {boolean}
 */


function isSticking(stickyElement) {
  var topSentinel = stickyElement.previousElementSibling;
  var stickyOffset = stickyElement.getBoundingClientRect().top;
  var topSentinelOffset = topSentinel.getBoundingClientRect().top;
  var difference = Math.round(Math.abs(stickyOffset - topSentinelOffset));
  var topSentinelTopPosition = Math.abs(parseInt(window.getComputedStyle(topSentinel).getPropertyValue('top')));
  return difference !== topSentinelTopPosition;
}

exports.StickyEvent = StickyEvent;
exports.default = StickyEvents;
exports.unobserveStickyEvents = unobserveStickyEvents;
exports.observeStickyEvents = observeStickyEvents;
